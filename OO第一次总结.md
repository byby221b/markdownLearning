---
title: OO第一次总结
tags: 新建,模板,小书匠
grammar_cjkRuby: true
---


## 一.代码度量分析
### &emsp;&emsp;1.第一次作业（多项式）
#### &emsp;&emsp;&emsp;&emsp;(1)代码度量及相应分析

| 度量值     | 总计 | 均值  | 标准差 | 最大值 |     |
| ---------- | ---- | ----- | ------ | ------ | --- |
| 圈复杂度   |      | 3.105 | 3.712  | 15     |     |
| 嵌套块深度 |      | 1.842 | 1.225  | 5      |     |
| 传入耦合   |      | 0     | 0      | 0      |     |
| 传出耦合   |      | 0     | 0      | 0      |     |
| 方法个数   | 18   | 4.5   | 2.693  | 8      |     |
| 属性个数   | 5    | 1.25  | 1.299  | 3      |     |
| 总代码行数 | 261  |       |        |        |     |
|类个数 |4 |      |        |        |     |
&emsp;&emsp;其中显示红色的是圈复杂度这一项，具体位置如下图所示：
![第一项作业截图] 
&emsp;&emsp;Andrew Glover在IBM官方网站上发表的<a href="https://www.ibm.com/developerworks/cn/java/j-cq03316/">监视圈复杂度</a>分析了圈复杂度对于代码质量的度量，他指出：
><b>圈复杂度</b>是在我前面提到的那些研究期间开创的，它可以精确地测量路径复杂度。通过利用某一方法路由不同的路径，这一基于整数的度量可适当地描述方法复杂度。实际上，过去几年的各种研究已经确定：圈复杂度（或 CC）大于 10 的方法存在很大的出错风险。

&emsp;&emsp;从截图可以看出，我CC值最高的方法是是<i>calcul</i>方法，由于该方法同时兼顾了输入处理和多项式拆分计算两个功能，因此if-else分支较多，导致代码逻辑复杂，可读性较差。减少圈复杂度的最有效方式是隔离代码部分，将它们放入新的方法中。在今后的编码中我也应该尽量避免这一问题，并且这次学会使用<i>Metrics</i>以后,今后就可以用它来实时监控自己是否书写了过于复杂的方法了。


#### &emsp;&emsp;&emsp;&emsp;(2)类图
### &emsp;&emsp;2.第二次作业（“傻瓜式”电梯）
#### &emsp;&emsp;&emsp;&emsp;(1)代码度量及相应分析
| 度量值     | 总计 | 均值  | 标准差 | 最大值 |     |
| ---------- | ---- | ----- | ------ | ------ | --- |
| 圈复杂度   |      |2.143 |2.9  | 12    |     |
| 嵌套块深度 |      | 1.4 | 1.101  | 6     |     |
| 传入耦合   |      | 0     | 0      | 0      |     |
| 传出耦合   |      | 0     | 0      | 0      |     |
| 方法个数   | 34   | 4.857   | 2.03  | 9      |     |
| 属性个数   | 16   | 2.286  | 1.385  | 5      |     |
| 总代码行数 |316  |       |        |        |     |
|类个数 |7 |      |        |        |     |
&emsp;&emsp;本次作业虽然需要处理的情形明显增多，但是圈复杂度相较第一次作业有所下降，可见编程习惯有所改善，不过圈复杂度仍然超过了边界10。此次复杂度较高的位置是在调度器中的控制方法和请求类的请求处理中，不得不说，由于需要考虑的特殊情况比较多，这两个方法的逻辑确实有些复杂，同时同一个if的条件也很复杂，虽然我尝试分行书写使得代码更加清晰，但这一做法对提高程序的可读性本身贡献较小。
![第二次作业的截图] 
&emsp;&emsp;本次作业通过度量发现的另一个问题是嵌套块深度过高，出现的位置是在输入处理阶段，由于我对不合法指令的区分比较细致，因此有一些if-else的嵌套，我在<a href="https://blog.csdn.net/longshengguoji/article/details/17250587">这篇博客</a>中找到了一些优化措施，以后编程中可以有意识地去使用。
* 尽量紧凑。一个函数只赋予一个职责。
* 不要自我重复。优先使用命名函数，而不要让相似的代码片段重复出现。
* 优先使用&&。在可以使用&&条件判断的地方要避免使用连续嵌套的if。
* 不要过分使用try。优先使用析构函数进行自动清除而避免使用try代码块。
* 优先使用标准算法。算法比循环嵌套要少，通常也更好。
* 不要根据类型标签进行分支。也就是尽量不要使用switch…..case语句，而要优先使用多态函数。
#### &emsp;&emsp;&emsp;&emsp;(2)类图
### &emsp;&emsp;3.第三次作业（ALS电梯）
#### &emsp;&emsp;&emsp;&emsp;(1)代码度量及相应分析
| 度量值     | 总计 | 均值  | 标准差 | 最大值 |     |
| ---------- | ---- | ----- | ------ | ------ | --- |
| 圈复杂度   |      |2.585 |3.51  | 18    |     |
| 嵌套块深度 |      | 1.585 | 1.295  | 6     |     |
| 传入耦合   |      | 0     | 0      | 0      |     |
| 传出耦合   |      | 0     | 0      | 0      |     |
| 方法个数   | 51   | 5.667   | 3.559  | 12      |     |
| 属性个数   | 22   | 2.444  | 2.217  | 7      |     |
| 总代码行数 |525  |       |        |        |     |
|类个数 |9 |      |        |        |     |
&emsp;&emsp;可以看到第三次作业的圈复杂度飙升，其实不需要度量工具，我在编写代码的时候就感觉到了自己所书写代码的复杂程度比较高，也因此漏写几句关键代码，知道后期测试的时候才补上，总结起来，一方面是第三次作业的大部分代码沿用自第二次作业，因此第二次代码隐藏的一些问题也继承给了第三次作业；另一方面则是<i>execute</i>等方法的层次划分不够，功能太多，导致复杂度上升。有一点可以肯定的是，关于<i>Scheduler</i>类，第二次作业和第三次作业的<i>Scheduler</i>类功能完全相同，都是“傻瓜式”调度器，但是我在沿用第二次作业代码的时候对该类进行了调整，把一个方法拆分成了具有不同功能的几个方法，圈复杂度也由此从第二次作业的12降到了第三次作业的5，这一提升也为今后降低代码的圈复杂度提供了思路。
#### &emsp;&emsp;&emsp;&emsp;(2)类图
## 二.分析自己的bug
## 三.测试策略
## 四.心得体会